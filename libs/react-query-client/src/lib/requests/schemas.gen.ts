// This file is auto-generated by @hey-api/openapi-ts

export const $CreateUserDto = {
    type: 'object',
    properties: {
        username: {
            type: 'string',
            example: 'johndoe',
            description: 'The username for the new user'
        },
        email: {
            type: 'string',
            example: 'john.doe@example.com',
            description: 'The email address for the new user'
        },
        password: {
            type: 'string',
            description: 'The password for the new user',
            example: 'password123'
        },
        strategy: {
            type: 'string',
            description: 'The authentication strategy to use',
            enum: ['local_password', 'sso'],
            example: 'local_password'
        }
    },
    required: ['username', 'email', 'password', 'strategy']
} as const;

export const $SystemPermissions = {
    type: 'object',
    properties: {
        canManageResources: {
            type: 'boolean',
            description: 'Whether the user can manage resources',
            example: false
        },
        canManageSystemConfiguration: {
            type: 'boolean',
            description: 'Whether the user can manage system configuration',
            example: false
        },
        canManageUsers: {
            type: 'boolean',
            description: 'Whether the user can manage users',
            example: false
        }
    },
    required: ['canManageResources', 'canManageSystemConfiguration', 'canManageUsers']
} as const;

export const $User = {
    type: 'object',
    properties: {
        id: {
            type: 'number',
            description: 'The unique identifier of the user',
            example: 1
        },
        username: {
            type: 'string',
            description: 'The username of the user',
            example: 'johndoe'
        },
        email: {
            type: 'string',
            description: 'The email address of the user',
            example: 'john@example.com'
        },
        isEmailVerified: {
            type: 'boolean',
            description: 'Whether the user has verified their email address',
            example: true
        },
        systemPermissions: {
            description: 'System-wide permissions for the user',
            example: {
                canManageResources: true,
                canManageSystemConfiguration: false,
                canManageUsers: false
            },
            allOf: [
                {
                    '$ref': '#/components/schemas/SystemPermissions'
                }
            ]
        },
        createdAt: {
            format: 'date-time',
            type: 'string',
            description: 'When the user was created'
        },
        updatedAt: {
            format: 'date-time',
            type: 'string',
            description: 'When the user was last updated'
        },
        externalIdentifier: {
            type: 'string',
            description: 'The external (origin) identifier of the user, if the user is authenticated via SSO',
            example: '1234567890',
            nullable: true
        }
    },
    required: ['id', 'username', 'email', 'isEmailVerified', 'systemPermissions', 'createdAt', 'updatedAt']
} as const;

export const $VerifyEmailDto = {
    type: 'object',
    properties: {
        token: {
            type: 'string',
            description: 'The token to verify the email',
            example: '1234567890'
        },
        email: {
            type: 'string',
            description: 'The email to verify',
            example: 'john.doe@example.com'
        }
    },
    required: ['token', 'email']
} as const;

export const $ResetPasswordDto = {
    type: 'object',
    properties: {}
} as const;

export const $ChangePasswordDto = {
    type: 'object',
    properties: {
        password: {
            type: 'string',
            description: 'The new password for the user',
            example: 'password123'
        },
        token: {
            type: 'string',
            description: 'The token for the user',
            example: '1234567890'
        }
    },
    required: ['password', 'token']
} as const;

export const $UserNotFoundException = {
    type: 'object',
    properties: {}
} as const;

export const $PaginatedUsersResponseDto = {
    type: 'object',
    properties: {
        total: {
            type: 'number'
        },
        page: {
            type: 'number'
        },
        limit: {
            type: 'number'
        },
        nextPage: {
            type: 'number',
            description: 'Next page number if there are more pages, null if this is the last page',
            example: 2,
            nullable: true
        },
        totalPages: {
            type: 'number',
            description: 'Total number of pages',
            example: 5
        },
        data: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/User'
            }
        }
    },
    required: ['total', 'page', 'limit', 'nextPage', 'totalPages', 'data']
} as const;

export const $UpdateUserPermissionsDto = {
    type: 'object',
    properties: {
        canManageResources: {
            type: 'boolean',
            description: 'Whether the user can manage resources',
            example: false
        },
        canManageSystemConfiguration: {
            type: 'boolean',
            description: 'Whether the user can manage system configuration',
            example: false
        },
        canManageUsers: {
            type: 'boolean',
            description: 'Whether the user can manage users',
            example: false
        }
    }
} as const;

export const $UserPermissionsUpdateItem = {
    type: 'object',
    properties: {
        userId: {
            type: 'number',
            description: 'The user ID',
            example: 1
        },
        permissions: {
            description: 'The permission updates to apply',
            example: {
                canManageResources: true,
                canManageSystemConfiguration: false,
                canManageUsers: false
            },
            allOf: [
                {
                    '$ref': '#/components/schemas/UpdateUserPermissionsDto'
                }
            ]
        }
    },
    required: ['userId', 'permissions']
} as const;

export const $BulkUpdateUserPermissionsDto = {
    type: 'object',
    properties: {
        updates: {
            description: 'Array of user permission updates',
            type: 'array',
            items: {
                '$ref': '#/components/schemas/UserPermissionsUpdateItem'
            }
        }
    },
    required: ['updates']
} as const;

export const $RequestEmailChangeDto = {
    type: 'object',
    properties: {
        newEmail: {
            type: 'string',
            description: 'The new email address',
            example: 'newemail@example.com'
        }
    },
    required: ['newEmail']
} as const;

export const $ConfirmEmailChangeDto = {
    type: 'object',
    properties: {
        newEmail: {
            type: 'string',
            description: 'The new email address to confirm',
            example: 'newemail@example.com'
        },
        token: {
            type: 'string',
            description: 'The verification token',
            example: 'abc123def456'
        }
    },
    required: ['newEmail', 'token']
} as const;

export const $AdminChangeEmailDto = {
    type: 'object',
    properties: {
        newEmail: {
            type: 'string',
            description: 'The new email address',
            example: 'newemail@example.com'
        }
    },
    required: ['newEmail']
} as const;

export const $CreateSessionResponse = {
    type: 'object',
    properties: {
        user: {
            description: 'The user that has been logged in',
            example: {
                id: 1,
                username: 'testuser'
            },
            allOf: [
                {
                    '$ref': '#/components/schemas/User'
                }
            ]
        },
        authToken: {
            type: 'string',
            description: 'The authentication token',
            example: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c'
        }
    },
    required: ['user', 'authToken']
} as const;

export const $SSOProviderType = {
    type: 'string',
    enum: ['OIDC'],
    description: 'The type of the provider'
} as const;

export const $SSOProviderOIDCConfiguration = {
    type: 'object',
    properties: {
        id: {
            type: 'number',
            description: 'The unique identifier of the provider',
            example: 1
        },
        ssoProviderId: {
            type: 'number',
            description: 'The ID of the SSO provider',
            example: 1
        },
        issuer: {
            type: 'string',
            description: 'The issuer of the provider',
            example: 'https://sso.csh.rit.edu/auth/realms/csh'
        },
        authorizationURL: {
            type: 'string',
            description: 'The authorization URL of the provider',
            example: 'https://sso.csh.rit.edu/auth/realms/csh/protocol/openid-connect/auth'
        },
        tokenURL: {
            type: 'string',
            description: 'The token URL of the provider',
            example: 'https://sso.csh.rit.edu/auth/realms/csh/protocol/openid-connect/token'
        },
        userInfoURL: {
            type: 'string',
            description: 'The user info URL of the provider',
            example: 'https://sso.csh.rit.edu/auth/realms/csh/protocol/openid-connect/userinfo'
        },
        clientId: {
            type: 'string',
            description: 'The client ID of the provider',
            example: '1234567890'
        },
        clientSecret: {
            type: 'string',
            description: 'The client secret of the provider',
            example: '1234567890'
        },
        createdAt: {
            format: 'date-time',
            type: 'string',
            description: 'When the user was created'
        },
        updatedAt: {
            format: 'date-time',
            type: 'string',
            description: 'When the user was last updated'
        }
    },
    required: ['id', 'ssoProviderId', 'issuer', 'authorizationURL', 'tokenURL', 'userInfoURL', 'clientId', 'clientSecret', 'createdAt', 'updatedAt']
} as const;

export const $SSOProvider = {
    type: 'object',
    properties: {
        id: {
            type: 'number',
            description: 'The unique identifier of the provider',
            example: 1
        },
        name: {
            type: 'string',
            description: 'The internal name of the provider',
            example: 'Keycloak'
        },
        type: {
            description: 'The type of the provider',
            example: 'OIDC',
            allOf: [
                {
                    '$ref': '#/components/schemas/SSOProviderType'
                }
            ]
        },
        createdAt: {
            format: 'date-time',
            type: 'string',
            description: 'When the user was created'
        },
        updatedAt: {
            format: 'date-time',
            type: 'string',
            description: 'When the user was last updated'
        },
        oidcConfiguration: {
            description: 'The OIDC configuration of the provider',
            allOf: [
                {
                    '$ref': '#/components/schemas/SSOProviderOIDCConfiguration'
                }
            ]
        }
    },
    required: ['id', 'name', 'type', 'createdAt', 'updatedAt', 'oidcConfiguration']
} as const;

export const $LinkUserToExternalAccountRequestDto = {
    type: 'object',
    properties: {
        email: {
            type: 'string',
            description: 'The email of the user',
            example: 'john.doe@example.com'
        },
        password: {
            type: 'string',
            description: 'The password of the user',
            example: 'password'
        },
        externalId: {
            type: 'string',
            description: 'The external identifier of the user',
            example: '1234567890'
        }
    },
    required: ['email', 'password', 'externalId']
} as const;

export const $CreateOIDCConfigurationDto = {
    type: 'object',
    properties: {
        issuer: {
            type: 'string',
            description: 'The issuer of the provider',
            example: 'https://sso.example.com/auth/realms/example'
        },
        authorizationURL: {
            type: 'string',
            description: 'The authorization URL of the provider',
            example: 'https://sso.example.com/auth/realms/example/protocol/openid-connect/auth'
        },
        tokenURL: {
            type: 'string',
            description: 'The token URL of the provider',
            example: 'https://sso.example.com/auth/realms/example/protocol/openid-connect/token'
        },
        userInfoURL: {
            type: 'string',
            description: 'The user info URL of the provider',
            example: 'https://sso.example.com/auth/realms/example/protocol/openid-connect/userinfo'
        },
        clientId: {
            type: 'string',
            description: 'The client ID of the provider',
            example: 'fabaccess-client'
        },
        clientSecret: {
            type: 'string',
            description: 'The client secret of the provider',
            example: 'client-secret'
        }
    },
    required: ['issuer', 'authorizationURL', 'tokenURL', 'userInfoURL', 'clientId', 'clientSecret']
} as const;

export const $CreateSSOProviderDto = {
    type: 'object',
    properties: {
        name: {
            type: 'string',
            description: 'The name of the SSO provider',
            example: 'Company Keycloak'
        },
        type: {
            type: 'string',
            description: 'The type of SSO provider',
            enum: ['OIDC'],
            example: 'OIDC'
        },
        oidcConfiguration: {
            description: 'The OIDC configuration for the provider',
            allOf: [
                {
                    '$ref': '#/components/schemas/CreateOIDCConfigurationDto'
                }
            ]
        }
    },
    required: ['name', 'type']
} as const;

export const $UpdateOIDCConfigurationDto = {
    type: 'object',
    properties: {
        issuer: {
            type: 'string',
            description: 'The issuer of the provider',
            example: 'https://sso.example.com/auth/realms/example'
        },
        authorizationURL: {
            type: 'string',
            description: 'The authorization URL of the provider',
            example: 'https://sso.example.com/auth/realms/example/protocol/openid-connect/auth'
        },
        tokenURL: {
            type: 'string',
            description: 'The token URL of the provider',
            example: 'https://sso.example.com/auth/realms/example/protocol/openid-connect/token'
        },
        userInfoURL: {
            type: 'string',
            description: 'The user info URL of the provider',
            example: 'https://sso.example.com/auth/realms/example/protocol/openid-connect/userinfo'
        },
        clientId: {
            type: 'string',
            description: 'The client ID of the provider',
            example: 'fabaccess-client'
        },
        clientSecret: {
            type: 'string',
            description: 'The client secret of the provider',
            example: 'client-secret'
        }
    }
} as const;

export const $UpdateSSOProviderDto = {
    type: 'object',
    properties: {
        name: {
            type: 'string',
            description: 'The name of the SSO provider',
            example: 'Company Keycloak'
        },
        oidcConfiguration: {
            description: 'The OIDC configuration for the provider',
            allOf: [
                {
                    '$ref': '#/components/schemas/UpdateOIDCConfigurationDto'
                }
            ]
        }
    }
} as const;

export const $PreviewMjmlDto = {
    type: 'object',
    properties: {
        mjmlContent: {
            type: 'string',
            description: 'The MJML content to preview',
            example: '<mjml><mj-body><mj-section><mj-column><mj-text>Hello, world!</mj-text></mj-column></mj-section></mj-body></mjml>'
        }
    },
    required: ['mjmlContent']
} as const;

export const $PreviewMjmlResponseDto = {
    type: 'object',
    properties: {
        html: {
            type: 'string',
            description: 'The HTML content of the MJML',
            example: '<div>Hello, world!</div>'
        },
        hasErrors: {
            type: 'boolean',
            description: 'Indicates if there were any errors during conversion',
            example: false
        },
        error: {
            type: 'string',
            description: 'Error message if conversion failed',
            example: null
        }
    },
    required: ['html', 'hasErrors']
} as const;

export const $EmailTemplateType = {
    type: 'string',
    enum: ['verify-email', 'reset-password', 'change-email'],
    description: 'Template type/key used by the system'
} as const;

export const $EmailTemplate = {
    type: 'object',
    properties: {
        type: {
            description: 'Template type/key used by the system',
            example: 'verify-email',
            allOf: [
                {
                    '$ref': '#/components/schemas/EmailTemplateType'
                }
            ]
        },
        subject: {
            type: 'string',
            description: 'Email subject line',
            example: 'Verify Your Email Address'
        },
        body: {
            type: 'string',
            description: 'MJML content of the email body'
        },
        variables: {
            description: 'Variables used in the email body',
            example: ['{{name}}', '{{url}}'],
            type: 'array',
            items: {
                type: 'string'
            }
        },
        createdAt: {
            format: 'date-time',
            type: 'string',
            description: 'Timestamp of when the template was created'
        },
        updatedAt: {
            format: 'date-time',
            type: 'string',
            description: 'Timestamp of when the template was last updated'
        }
    },
    required: ['type', 'subject', 'body', 'variables', 'createdAt', 'updatedAt']
} as const;

export const $UpdateEmailTemplateDto = {
    type: 'object',
    properties: {
        subject: {
            type: 'string',
            description: 'Email subject line',
            maxLength: 255
        },
        body: {
            type: 'string',
            description: 'MJML content of the email body'
        }
    }
} as const;

export const $CreateResourceDto = {
    type: 'object',
    properties: {
        name: {
            type: 'string',
            description: 'The name of the resource',
            example: '3D Printer'
        },
        description: {
            type: 'string',
            description: 'A detailed description of the resource',
            example: 'Prusa i3 MK3S+ 3D printer with 0.4mm nozzle'
        },
        image: {
            type: 'string',
            description: 'Resource image file',
            format: 'binary'
        },
        documentationType: {
            type: 'string',
            description: 'The type of documentation (markdown or url)',
            enum: ['markdown', 'url'],
            example: 'markdown'
        },
        documentationMarkdown: {
            type: 'string',
            description: 'Markdown content for resource documentation',
            example: `# Resource Documentation

This is a markdown documentation for the resource.`
        },
        documentationUrl: {
            type: 'string',
            description: 'URL to external documentation',
            example: 'https://example.com/documentation'
        },
        allowTakeOver: {
            type: 'boolean',
            description: 'Whether this resource allows overtaking by the next user without the prior user ending their session',
            example: false,
            default: false
        }
    },
    required: ['name']
} as const;

export const $ResourceGroup = {
    type: 'object',
    properties: {
        id: {
            type: 'number',
            description: 'The unique identifier of the resource group',
            example: 1
        },
        name: {
            type: 'string',
            description: 'The name of the resource',
            example: '3D Printer'
        },
        description: {
            type: 'string',
            description: 'A detailed description of the resource',
            example: 'Prusa i3 MK3S+ 3D printer with 0.4mm nozzle'
        },
        createdAt: {
            format: 'date-time',
            type: 'string',
            description: 'When the resource was created'
        },
        updatedAt: {
            format: 'date-time',
            type: 'string',
            description: 'When the resource was last updated'
        }
    },
    required: ['id', 'name', 'createdAt', 'updatedAt']
} as const;

export const $Resource = {
    type: 'object',
    properties: {
        id: {
            type: 'number',
            description: 'The unique identifier of the resource',
            example: 1
        },
        name: {
            type: 'string',
            description: 'The name of the resource',
            example: '3D Printer'
        },
        description: {
            type: 'string',
            description: 'A detailed description of the resource',
            example: 'Prusa i3 MK3S+ 3D printer with 0.4mm nozzle'
        },
        imageFilename: {
            type: 'string',
            description: 'The filename of the resource image',
            example: '1234567890_abcdef.jpg'
        },
        documentationType: {
            type: 'string',
            description: 'The type of documentation (markdown or url)',
            enum: ['markdown', 'url'],
            example: 'markdown'
        },
        documentationMarkdown: {
            type: 'string',
            description: 'Markdown content for resource documentation',
            example: `# Resource Documentation

This is a markdown documentation for the resource.`
        },
        documentationUrl: {
            type: 'string',
            description: 'URL to external documentation',
            example: 'https://example.com/documentation'
        },
        allowTakeOver: {
            type: 'boolean',
            description: 'Whether this resource allows overtaking by the next user without the prior user ending their session',
            example: false,
            default: false
        },
        createdAt: {
            format: 'date-time',
            type: 'string',
            description: 'When the resource was created'
        },
        updatedAt: {
            format: 'date-time',
            type: 'string',
            description: 'When the resource was last updated'
        },
        groups: {
            description: 'The groups the resource belongs to',
            type: 'array',
            items: {
                '$ref': '#/components/schemas/ResourceGroup'
            }
        }
    },
    required: ['id', 'name', 'allowTakeOver', 'createdAt', 'updatedAt', 'groups']
} as const;

export const $PaginatedResourceResponseDto = {
    type: 'object',
    properties: {
        total: {
            type: 'number'
        },
        page: {
            type: 'number'
        },
        limit: {
            type: 'number'
        },
        nextPage: {
            type: 'number',
            description: 'Next page number if there are more pages, null if this is the last page',
            example: 2,
            nullable: true
        },
        totalPages: {
            type: 'number',
            description: 'Total number of pages',
            example: 5
        },
        data: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/Resource'
            }
        }
    },
    required: ['total', 'page', 'limit', 'nextPage', 'totalPages', 'data']
} as const;

export const $UpdateResourceDto = {
    type: 'object',
    properties: {
        name: {
            type: 'string',
            description: 'The name of the resource',
            example: '3D Printer'
        },
        description: {
            type: 'string',
            description: 'A detailed description of the resource',
            example: 'Prusa i3 MK3S+ 3D printer with 0.4mm nozzle'
        },
        image: {
            type: 'string',
            description: 'New resource image file',
            format: 'binary'
        },
        deleteImage: {
            type: 'boolean',
            description: 'Whether the resource image should be deleted',
            default: false
        },
        documentationType: {
            type: 'string',
            description: 'The type of documentation (markdown or url)',
            enum: ['markdown', 'url'],
            example: 'markdown'
        },
        documentationMarkdown: {
            type: 'string',
            description: 'Markdown content for resource documentation',
            example: `# Resource Documentation

This is a markdown documentation for the resource.`
        },
        documentationUrl: {
            type: 'string',
            description: 'URL to external documentation',
            example: 'https://example.com/documentation'
        },
        allowTakeOver: {
            type: 'boolean',
            description: 'Whether this resource allows overtaking by the next user without the prior user ending their session',
            example: false
        }
    }
} as const;

export const $MqttServer = {
    type: 'object',
    properties: {
        id: {
            type: 'number',
            description: 'The unique identifier of the MQTT server',
            example: 1
        },
        name: {
            type: 'string',
            description: 'Friendly name for the MQTT server',
            example: 'Workshop MQTT Server'
        },
        host: {
            type: 'string',
            description: 'MQTT server hostname/IP',
            example: 'mqtt.example.com'
        },
        port: {
            type: 'number',
            description: 'MQTT server port (default: 1883 for MQTT, 8883 for MQTTS)',
            example: 1883
        },
        username: {
            type: 'string',
            description: 'Optional authentication username',
            example: 'mqttuser'
        },
        password: {
            type: 'string',
            description: 'Optional authentication password',
            example: 'password123'
        },
        clientId: {
            type: 'string',
            description: 'Client ID for MQTT connection',
            example: 'fabaccess-client-1'
        },
        useTls: {
            type: 'boolean',
            description: 'Whether to use TLS/SSL',
            example: false
        },
        createdAt: {
            format: 'date-time',
            type: 'string',
            description: 'When the MQTT server was created'
        },
        updatedAt: {
            format: 'date-time',
            type: 'string',
            description: 'When the MQTT server was last updated'
        }
    },
    required: ['id', 'name', 'host', 'port', 'useTls', 'createdAt', 'updatedAt']
} as const;

export const $CreateMqttServerDto = {
    type: 'object',
    properties: {
        name: {
            type: 'string',
            description: 'Friendly name for the MQTT server'
        },
        host: {
            type: 'string',
            description: 'Hostname or IP address of the MQTT server'
        },
        port: {
            type: 'number',
            description: 'Port number of the MQTT server',
            example: 1883
        },
        username: {
            type: 'string',
            description: 'Optional username for authentication'
        },
        password: {
            type: 'string',
            description: 'Optional password for authentication'
        },
        clientId: {
            type: 'string',
            description: 'Optional client ID for MQTT connection'
        },
        useTls: {
            type: 'boolean',
            description: 'Whether to use TLS/SSL for the connection',
            default: false
        }
    },
    required: ['name', 'host', 'port']
} as const;

export const $UpdateMqttServerDto = {
    type: 'object',
    properties: {
        name: {
            type: 'string',
            description: 'Friendly name for the MQTT server'
        },
        host: {
            type: 'string',
            description: 'Hostname or IP address of the MQTT server'
        },
        port: {
            type: 'number',
            description: 'Port number of the MQTT server',
            example: 1883
        },
        username: {
            type: 'string',
            description: 'Optional username for authentication'
        },
        password: {
            type: 'string',
            description: 'Optional password for authentication'
        },
        clientId: {
            type: 'string',
            description: 'Optional client ID for MQTT connection'
        },
        useTls: {
            type: 'boolean',
            description: 'Whether to use TLS/SSL for the connection',
            default: false
        }
    }
} as const;

export const $TestConnectionResponseDto = {
    type: 'object',
    properties: {
        success: {
            type: 'boolean',
            description: 'Whether the connection test was successful',
            example: true
        },
        message: {
            type: 'string',
            description: 'Message describing the test result',
            example: 'Connection successful'
        }
    },
    required: ['success', 'message']
} as const;

export const $MqttHealthStatusDto = {
    type: 'object',
    properties: {
        healthy: {
            type: 'boolean',
            description: 'Whether the connection is healthy',
            example: true
        },
        details: {
            type: 'string',
            description: 'Detailed health status message',
            example: 'Connected: true, Failures: 0/3, Messages: 10 sent, 0 failed'
        }
    },
    required: ['healthy', 'details']
} as const;

export const $MqttConnectionStatsDto = {
    type: 'object',
    properties: {
        connectionAttempts: {
            type: 'number',
            description: 'Number of connection attempts',
            example: 5
        },
        connectionFailures: {
            type: 'number',
            description: 'Number of failed connections',
            example: 1
        },
        connectionSuccesses: {
            type: 'number',
            description: 'Number of successful connections',
            example: 4
        },
        lastConnectTime: {
            format: 'date-time',
            type: 'string',
            description: 'Timestamp of last successful connection',
            example: '2023-01-01T12:00:00.000Z'
        },
        lastDisconnectTime: {
            format: 'date-time',
            type: 'string',
            description: 'Timestamp of last disconnection',
            example: '2023-01-01T12:30:00.000Z'
        }
    },
    required: ['connectionAttempts', 'connectionFailures', 'connectionSuccesses']
} as const;

export const $MqttMessageStatsDto = {
    type: 'object',
    properties: {
        published: {
            type: 'number',
            description: 'Number of successfully published messages',
            example: 42
        },
        failed: {
            type: 'number',
            description: 'Number of failed message publications',
            example: 3
        },
        lastPublishTime: {
            format: 'date-time',
            type: 'string',
            description: 'Timestamp of last successful message publication',
            example: '2023-01-01T12:15:00.000Z'
        },
        lastFailureTime: {
            format: 'date-time',
            type: 'string',
            description: 'Timestamp of last failed message publication',
            example: '2023-01-01T12:10:00.000Z'
        }
    },
    required: ['published', 'failed']
} as const;

export const $MqttServerStatsDto = {
    type: 'object',
    properties: {
        connection: {
            description: 'Connection statistics',
            allOf: [
                {
                    '$ref': '#/components/schemas/MqttConnectionStatsDto'
                }
            ]
        },
        messages: {
            description: 'Message statistics',
            allOf: [
                {
                    '$ref': '#/components/schemas/MqttMessageStatsDto'
                }
            ]
        }
    },
    required: ['connection', 'messages']
} as const;

export const $MqttServerStatusDto = {
    type: 'object',
    properties: {
        connected: {
            type: 'boolean',
            description: 'Whether the server is currently connected',
            example: true
        },
        healthStatus: {
            description: 'Health status of the connection',
            allOf: [
                {
                    '$ref': '#/components/schemas/MqttHealthStatusDto'
                }
            ]
        },
        stats: {
            description: 'Detailed statistics',
            allOf: [
                {
                    '$ref': '#/components/schemas/MqttServerStatsDto'
                }
            ]
        }
    },
    required: ['connected', 'healthStatus', 'stats']
} as const;

export const $AllMqttServerStatusesDto = {
    type: 'object',
    properties: {
        servers: {
            type: 'object',
            description: 'Map of server IDs to their statuses',
            additionalProperties: {
                type: 'object',
                '$ref': '#/components/schemas/MqttServerStatusDto'
            }
        }
    },
    required: ['servers']
} as const;

export const $WebhookConfigResponseDto = {
    type: 'object',
    properties: {
        id: {
            type: 'number',
            description: 'The unique identifier of the webhook configuration',
            example: 1
        },
        resourceId: {
            type: 'number',
            description: 'The ID of the resource this webhook configuration is for',
            example: 1
        },
        name: {
            type: 'string',
            description: 'Friendly name for the webhook',
            example: 'Slack Notification'
        },
        url: {
            type: 'string',
            description: 'Destination URL for the webhook. Supports templating with variables like {{id}}, {{name}}, {{event}}, etc.',
            example: 'https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXXXXXX'
        },
        method: {
            type: 'string',
            description: 'HTTP method to use for the webhook request',
            enum: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'],
            example: 'POST'
        },
        headers: {
            type: 'string',
            description: 'JSON object for custom headers. Values can include templates like {{id}}, {{name}}, etc.',
            example: '{"Content-Type": "application/json", "Authorization": "Bearer token123", "X-Resource-Name": "{{name}}"}'
        },
        inUseTemplate: {
            type: 'string',
            description: 'Template for payload when resource is in use',
            example: '{"status": "in_use", "resource": "{{name}}", "user": "{{user.name}}", "timestamp": "{{timestamp}}"}'
        },
        notInUseTemplate: {
            type: 'string',
            description: 'Template for payload when resource is not in use',
            example: '{"status": "not_in_use", "resource": "{{name}}", "timestamp": "{{timestamp}}"}'
        },
        active: {
            type: 'boolean',
            description: 'Whether the webhook is active',
            example: true
        },
        retryEnabled: {
            type: 'boolean',
            description: 'Whether to enable retry mechanism for failed webhook requests',
            example: true
        },
        maxRetries: {
            type: 'number',
            description: 'Number of retry attempts for failed webhook requests',
            example: 3
        },
        retryDelay: {
            type: 'number',
            description: 'Delay in milliseconds between retries',
            example: 1000
        },
        signatureHeader: {
            type: 'string',
            description: 'Name of the header that contains the signature',
            example: 'X-Webhook-Signature'
        },
        sendOnStart: {
            type: 'boolean',
            description: 'Whether to send a webhook when a resource usage starts',
            example: true
        },
        sendOnStop: {
            type: 'boolean',
            description: 'Whether to send a webhook when a resource usage stops',
            example: true
        },
        sendOnTakeover: {
            type: 'boolean',
            description: 'Whether to send a webhook when a resource usage is taken over',
            example: false
        },
        takeoverTemplate: {
            type: 'string',
            description: 'Template for payload when resource usage is taken over',
            example: '{"status": "taken_over", "resource": "{{name}}", "newUser": "{{user.name}}", "previousUser": "{{previousUser.name}}", "timestamp": "{{timestamp}}"}'
        },
        createdAt: {
            format: 'date-time',
            type: 'string',
            description: 'When the webhook configuration was created'
        },
        updatedAt: {
            format: 'date-time',
            type: 'string',
            description: 'When the webhook configuration was last updated'
        }
    },
    required: ['id', 'resourceId', 'name', 'url', 'method', 'headers', 'inUseTemplate', 'notInUseTemplate', 'active', 'retryEnabled', 'maxRetries', 'retryDelay', 'signatureHeader', 'sendOnStart', 'sendOnStop', 'sendOnTakeover', 'takeoverTemplate', 'createdAt', 'updatedAt']
} as const;

export const $CreateWebhookConfigDto = {
    type: 'object',
    properties: {
        name: {
            type: 'string',
            description: 'Friendly name for the webhook',
            example: 'Slack Notification'
        },
        url: {
            type: 'string',
            description: 'Destination URL for the webhook. Supports templating with variables like {{id}}, {{name}}, {{event}}, etc.',
            example: 'https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXXXXXX'
        },
        method: {
            type: 'string',
            description: 'HTTP method to use for the webhook request',
            enum: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'],
            example: 'POST'
        },
        headers: {
            type: 'string',
            description: 'JSON object for custom headers. Values can include templates like {{id}}, {{name}}, etc.',
            example: '{"Content-Type": "application/json", "Authorization": "Bearer token123", "X-Resource-Name": "{{name}}"}'
        },
        inUseTemplate: {
            type: 'string',
            description: 'Template for payload when resource is in use',
            example: '{"status": "in_use", "resource": "{{name}}", "user": "{{user.name}}", "timestamp": "{{timestamp}}"}'
        },
        notInUseTemplate: {
            type: 'string',
            description: 'Template for payload when resource is not in use',
            example: '{"status": "not_in_use", "resource": "{{name}}", "timestamp": "{{timestamp}}"}'
        },
        active: {
            type: 'boolean',
            description: 'Whether the webhook is active',
            example: true,
            default: true
        },
        retryEnabled: {
            type: 'boolean',
            description: 'Whether to enable retry mechanism for failed webhook requests',
            example: true,
            default: false
        },
        maxRetries: {
            type: 'number',
            description: 'Number of retry attempts for failed webhook requests (maximum 10)',
            example: 3,
            default: 3
        },
        retryDelay: {
            type: 'number',
            description: 'Delay in milliseconds between retries (maximum 10000)',
            example: 1000,
            default: 1000
        },
        signatureHeader: {
            type: 'string',
            description: 'Name of the header that contains the signature',
            example: 'X-Webhook-Signature',
            default: 'X-Webhook-Signature'
        },
        sendOnStart: {
            type: 'boolean',
            description: 'Whether to send a webhook when a resource usage starts',
            example: true,
            default: true
        },
        sendOnStop: {
            type: 'boolean',
            description: 'Whether to send a webhook when a resource usage stops',
            example: true,
            default: true
        },
        sendOnTakeover: {
            type: 'boolean',
            description: 'Whether to send a webhook when a resource usage is taken over',
            example: false,
            default: false
        },
        takeoverTemplate: {
            type: 'string',
            description: 'Template for payload when resource usage is taken over',
            example: '{"status": "taken_over", "resource": "{{name}}", "newUser": "{{user.name}}", "previousUser": "{{previousUser.name}}", "timestamp": "{{timestamp}}"}'
        }
    },
    required: ['name', 'url', 'method', 'inUseTemplate', 'notInUseTemplate']
} as const;

export const $UpdateWebhookConfigDto = {
    type: 'object',
    properties: {
        name: {
            type: 'string',
            description: 'Friendly name for the webhook',
            example: 'Slack Notification'
        },
        url: {
            type: 'string',
            description: 'Destination URL for the webhook. Supports templating with variables like {{id}}, {{name}}, {{event}}, etc.',
            example: 'https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXXXXXX'
        },
        method: {
            type: 'string',
            description: 'HTTP method to use for the webhook request',
            enum: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'],
            example: 'POST'
        },
        headers: {
            type: 'string',
            description: 'JSON object for custom headers. Values can include templates like {{id}}, {{name}}, etc.',
            example: '{"Content-Type": "application/json", "Authorization": "Bearer token123", "X-Resource-Name": "{{name}}"}'
        },
        inUseTemplate: {
            type: 'string',
            description: 'Template for payload when resource is in use',
            example: '{"status": "in_use", "resource": "{{name}}", "user": "{{user.name}}", "timestamp": "{{timestamp}}"}'
        },
        notInUseTemplate: {
            type: 'string',
            description: 'Template for payload when resource is not in use',
            example: '{"status": "not_in_use", "resource": "{{name}}", "timestamp": "{{timestamp}}"}'
        },
        retryEnabled: {
            type: 'boolean',
            description: 'Whether to enable retry mechanism for failed webhook requests',
            example: true
        },
        maxRetries: {
            type: 'number',
            description: 'Number of retry attempts for failed webhook requests (maximum 10)',
            example: 3
        },
        retryDelay: {
            type: 'number',
            description: 'Delay in milliseconds between retries (maximum 10000)',
            example: 1000
        },
        signatureHeader: {
            type: 'string',
            description: 'Name of the header that contains the signature',
            example: 'X-Webhook-Signature'
        },
        sendOnStart: {
            type: 'boolean',
            description: 'Whether to send a webhook when a resource usage starts',
            example: true
        },
        sendOnStop: {
            type: 'boolean',
            description: 'Whether to send a webhook when a resource usage stops',
            example: true
        },
        sendOnTakeover: {
            type: 'boolean',
            description: 'Whether to send a webhook when a resource usage is taken over',
            example: false
        },
        takeoverTemplate: {
            type: 'string',
            description: 'Template for payload when resource usage is taken over',
            example: '{"status": "taken_over", "resource": "{{name}}", "newUser": "{{user.name}}", "previousUser": "{{previousUser.name}}", "timestamp": "{{timestamp}}"}'
        }
    }
} as const;

export const $WebhookStatusDto = {
    type: 'object',
    properties: {
        active: {
            type: 'boolean',
            description: 'Whether the webhook is active',
            example: true
        }
    },
    required: ['active']
} as const;

export const $WebhookTestResponseDto = {
    type: 'object',
    properties: {
        success: {
            type: 'boolean',
            description: 'Whether the test was successful',
            example: true
        },
        message: {
            type: 'string',
            description: 'Message describing the test result',
            example: 'Webhook test request sent successfully'
        }
    },
    required: ['success', 'message']
} as const;

export const $MqttResourceConfig = {
    type: 'object',
    properties: {
        id: {
            type: 'number',
            description: 'The unique identifier of the MQTT resource configuration',
            example: 1
        },
        resourceId: {
            type: 'number',
            description: 'The ID of the resource this configuration is for',
            example: 1
        },
        name: {
            type: 'string',
            description: 'Name of this MQTT configuration',
            example: 'Primary Status Feed'
        },
        serverId: {
            type: 'number',
            description: 'The ID of the MQTT server to publish to',
            example: 1
        },
        inUseTopic: {
            type: 'string',
            description: 'Topic template using Handlebars for in-use status',
            example: 'resources/{{id}}/status'
        },
        inUseMessage: {
            type: 'string',
            description: 'Message template using Handlebars for in-use status',
            example: '{"status": "in_use", "resourceId": "{{id}}", "timestamp": "{{timestamp}}"}'
        },
        notInUseTopic: {
            type: 'string',
            description: 'Topic template using Handlebars for not-in-use status',
            example: 'resources/{{id}}/status'
        },
        notInUseMessage: {
            type: 'string',
            description: 'Message template using Handlebars for not-in-use status',
            example: '{"status": "not_in_use", "resourceId": "{{id}}", "timestamp": "{{timestamp}}"}'
        },
        onTakeoverSendStart: {
            type: 'boolean',
            description: 'Whether to send a start message when a resource is taken over',
            example: true
        },
        onTakeoverSendStop: {
            type: 'boolean',
            description: 'Whether to send a stop message when a resource is taken over',
            example: true
        },
        onTakeoverSendTakeover: {
            type: 'boolean',
            description: 'Whether to send an MQTT message when a resource usage is taken over',
            example: false
        },
        takeoverTopic: {
            type: 'string',
            description: 'Topic template using Handlebars for takeover status',
            example: 'resources/{{id}}/status'
        },
        takeoverMessage: {
            type: 'string',
            description: 'Message template using Handlebars for takeover status',
            example: '{"status": "taken_over", "resourceId": "{{id}}", "newUser": "{{user.name}}", "previousUser": "{{previousUser.name}}", "timestamp": "{{timestamp}}"}'
        },
        createdAt: {
            format: 'date-time',
            type: 'string',
            description: 'When the MQTT resource configuration was created'
        },
        updatedAt: {
            format: 'date-time',
            type: 'string',
            description: 'When the MQTT resource configuration was last updated'
        }
    },
    required: ['id', 'resourceId', 'name', 'serverId', 'inUseTopic', 'inUseMessage', 'notInUseTopic', 'notInUseMessage', 'onTakeoverSendStart', 'onTakeoverSendStop', 'onTakeoverSendTakeover', 'createdAt', 'updatedAt']
} as const;

export const $CreateMqttResourceConfigDto = {
    type: 'object',
    properties: {
        serverId: {
            type: 'number',
            description: 'ID of the MQTT server to use',
            example: 1
        },
        name: {
            type: 'string',
            description: 'Name of this MQTT configuration',
            example: 'Primary Status Feed'
        },
        inUseTopic: {
            type: 'string',
            description: 'Topic template for when resource is in use',
            example: 'resources/{{id}}/status'
        },
        inUseMessage: {
            type: 'string',
            description: 'Message template for when resource is in use',
            example: '{"status":"in_use","resourceId":{{id}},"resourceName":"{{name}}"}'
        },
        notInUseTopic: {
            type: 'string',
            description: 'Topic template for when resource is not in use',
            example: 'resources/{{id}}/status'
        },
        notInUseMessage: {
            type: 'string',
            description: 'Message template for when resource is not in use',
            example: '{"status":"not_in_use","resourceId":{{id}},"resourceName":"{{name}}"}'
        },
        onTakeoverSendStart: {
            type: 'boolean',
            description: 'Whether to send a start message when a resource is taken over',
            example: false,
            default: false
        },
        onTakeoverSendStop: {
            type: 'boolean',
            description: 'Whether to send a stop message when a resource is taken over',
            example: false,
            default: false
        },
        onTakeoverSendTakeover: {
            type: 'boolean',
            description: 'Whether to send an MQTT message when a resource usage is taken over',
            example: true,
            default: true
        },
        takeoverTopic: {
            type: 'string',
            description: 'Topic template for when resource usage is taken over',
            example: 'resources/{{id}}/status'
        },
        takeoverMessage: {
            type: 'string',
            description: 'Message template for when resource usage is taken over',
            example: '{"status": "taken_over", "resourceId": "{{id}}", "newUser": "{{user.name}}", "previousUser": "{{previousUser.name}}", "timestamp": "{{timestamp}}"}'
        }
    },
    required: ['serverId', 'name', 'inUseTopic', 'inUseMessage', 'notInUseTopic', 'notInUseMessage']
} as const;

export const $UpdateMqttResourceConfigDto = {
    type: 'object',
    properties: {
        serverId: {
            type: 'number',
            description: 'ID of the MQTT server to use',
            example: 1
        },
        name: {
            type: 'string',
            description: 'Name of this MQTT configuration',
            example: 'Primary Status Feed'
        },
        inUseTopic: {
            type: 'string',
            description: 'Topic template for when resource is in use',
            example: 'resources/{{id}}/status'
        },
        inUseMessage: {
            type: 'string',
            description: 'Message template for when resource is in use',
            example: '{"status":"in_use","resourceId":{{id}},"resourceName":"{{name}}"}'
        },
        notInUseTopic: {
            type: 'string',
            description: 'Topic template for when resource is not in use',
            example: 'resources/{{id}}/status'
        },
        notInUseMessage: {
            type: 'string',
            description: 'Message template for when resource is not in use',
            example: '{"status":"not_in_use","resourceId":{{id}},"resourceName":"{{name}}"}'
        },
        onTakeoverSendStart: {
            type: 'boolean',
            description: 'Whether to send a start message when a resource is taken over',
            example: false,
            default: false
        },
        onTakeoverSendStop: {
            type: 'boolean',
            description: 'Whether to send a stop message when a resource is taken over',
            example: false,
            default: false
        },
        onTakeoverSendTakeover: {
            type: 'boolean',
            description: 'Whether to send an MQTT message when a resource usage is taken over',
            example: true,
            default: true
        },
        takeoverTopic: {
            type: 'string',
            description: 'Topic template for when resource usage is taken over',
            example: 'resources/{{id}}/status'
        },
        takeoverMessage: {
            type: 'string',
            description: 'Message template for when resource usage is taken over',
            example: '{"status": "taken_over", "resourceId": "{{id}}", "newUser": "{{user.name}}", "previousUser": "{{previousUser.name}}", "timestamp": "{{timestamp}}"}'
        }
    }
} as const;

export const $TestMqttConfigResponseDto = {
    type: 'object',
    properties: {
        success: {
            type: 'boolean',
            description: 'Whether the test was successful',
            example: true
        },
        message: {
            type: 'string',
            description: 'Message describing the test result',
            example: 'MQTT configuration is valid and connection to server was successful'
        }
    },
    required: ['success', 'message']
} as const;

export const $CreateResourceGroupDto = {
    type: 'object',
    properties: {
        name: {
            type: 'string',
            description: 'The name of the resource group',
            example: 'Resource Group 1'
        },
        description: {
            type: 'string',
            description: 'The description of the resource group',
            example: 'This is a resource group'
        }
    },
    required: ['name']
} as const;

export const $UpdateResourceGroupDto = {
    type: 'object',
    properties: {
        name: {
            type: 'string',
            description: 'The name of the resource group',
            example: 'Resource Group 1'
        },
        description: {
            type: 'string',
            description: 'The description of the resource group',
            example: 'This is a resource group'
        }
    },
    required: ['name']
} as const;

export const $ResourceIntroductionHistoryItem = {
    type: 'object',
    properties: {
        id: {
            type: 'number',
            description: 'The unique identifier of the introduction history entry',
            example: 1
        },
        introductionId: {
            type: 'number',
            description: 'The ID of the related introduction',
            example: 1
        },
        action: {
            type: 'string',
            description: 'The action performed (revoke or grant)',
            enum: ['revoke', 'grant'],
            example: 'revoke'
        },
        performedByUserId: {
            type: 'number',
            description: 'The ID of the user who performed the action',
            example: 1
        },
        comment: {
            type: 'string',
            description: 'Optional comment explaining the reason for the action',
            example: 'User no longer requires access to this resource'
        },
        createdAt: {
            format: 'date-time',
            type: 'string',
            description: 'When the action was performed',
            example: '2021-01-01T00:00:00.000Z'
        },
        performedByUser: {
            description: 'The user who performed the action',
            allOf: [
                {
                    '$ref': '#/components/schemas/User'
                }
            ]
        }
    },
    required: ['id', 'introductionId', 'action', 'performedByUserId', 'createdAt', 'performedByUser']
} as const;

export const $ResourceIntroduction = {
    type: 'object',
    properties: {
        id: {
            type: 'number',
            description: 'The unique identifier of the introduction',
            example: 1
        },
        resourceId: {
            type: 'number',
            description: 'The ID of the resource (if this is a resource-specific introduction)',
            example: 1
        },
        receiverUserId: {
            type: 'number',
            description: 'The ID of the user who received the introduction',
            example: 1
        },
        tutorUserId: {
            type: 'number',
            description: 'The ID of the user who tutored the receiver',
            example: 2
        },
        resourceGroupId: {
            type: 'number',
            description: 'The ID of the resource group (if this is a group-level introduction)',
            example: 1
        },
        completedAt: {
            format: 'date-time',
            type: 'string',
            description: 'When the introduction was completed',
            example: '2021-01-01T00:00:00.000Z'
        },
        createdAt: {
            format: 'date-time',
            type: 'string',
            description: 'When the introduction record was created',
            example: '2021-01-01T00:00:00.000Z'
        },
        receiverUser: {
            description: 'The user who received the introduction',
            allOf: [
                {
                    '$ref': '#/components/schemas/User'
                }
            ]
        },
        tutorUser: {
            description: 'The user who tutored the receiver',
            allOf: [
                {
                    '$ref': '#/components/schemas/User'
                }
            ]
        },
        history: {
            description: 'History of revoke/unrevoke actions for this introduction',
            type: 'array',
            items: {
                '$ref': '#/components/schemas/ResourceIntroductionHistoryItem'
            }
        }
    },
    required: ['id', 'receiverUserId', 'tutorUserId', 'completedAt', 'createdAt', 'receiverUser', 'tutorUser', 'history']
} as const;

export const $UpdateResourceGroupIntroductionDto = {
    type: 'object',
    properties: {
        comment: {
            type: 'string',
            description: 'The comment for the action',
            example: 'This is a comment'
        }
    }
} as const;

export const $ResourceIntroducer = {
    type: 'object',
    properties: {
        id: {
            type: 'number',
            description: 'The unique identifier of the introduction permission',
            example: 1
        },
        resourceId: {
            type: 'number',
            description: 'The ID of the resource (if permission is for a specific resource)',
            example: 1
        },
        userId: {
            type: 'number',
            description: 'The ID of the user who can give introductions',
            example: 1
        },
        resourceGroupId: {
            type: 'number',
            description: 'The ID of the resource group (if permission is for a group)',
            example: 1
        },
        grantedAt: {
            format: 'date-time',
            type: 'string',
            description: 'When the permission was granted'
        },
        user: {
            description: 'The user who can give introductions',
            allOf: [
                {
                    '$ref': '#/components/schemas/User'
                }
            ]
        }
    },
    required: ['id', 'userId', 'grantedAt', 'user']
} as const;

export const $IsResourceGroupIntroducerResponseDto = {
    type: 'object',
    properties: {
        isIntroducer: {
            type: 'boolean',
            description: 'Whether the user is an introducer for the resource'
        }
    },
    required: ['isIntroducer']
} as const;

export const $StartUsageSessionDto = {
    type: 'object',
    properties: {
        notes: {
            type: 'string',
            description: 'Optional notes about the usage session',
            example: 'Printing a prototype case'
        },
        forceTakeOver: {
            type: 'boolean',
            description: 'Whether to force takeover of an existing session (only works if resource allows takeover)',
            example: false,
            default: false
        }
    }
} as const;

export const $ResourceUsage = {
    type: 'object',
    properties: {
        id: {
            type: 'number',
            description: 'The unique identifier of the resource usage',
            example: 1
        },
        resourceId: {
            type: 'number',
            description: 'The ID of the resource being used',
            example: 1
        },
        userId: {
            type: 'number',
            description: 'The ID of the user using the resource (null if user was deleted)',
            example: 1
        },
        startTime: {
            format: 'date-time',
            type: 'string',
            description: 'When the usage session started'
        },
        startNotes: {
            type: 'string',
            description: 'Notes provided when starting the session',
            example: 'Starting prototype development for client XYZ'
        },
        endTime: {
            format: 'date-time',
            type: 'string',
            description: 'When the usage session ended'
        },
        endNotes: {
            type: 'string',
            description: 'Notes provided when ending the session',
            example: 'Completed initial prototype, material usage: 500g'
        },
        resource: {
            description: 'The resource being used',
            allOf: [
                {
                    '$ref': '#/components/schemas/Resource'
                }
            ]
        },
        user: {
            description: 'The user who used the resource',
            allOf: [
                {
                    '$ref': '#/components/schemas/User'
                }
            ]
        },
        usageInMinutes: {
            type: 'number',
            description: 'The duration of the usage session in minutes',
            example: 120
        }
    },
    required: ['id', 'resourceId', 'startTime', 'usageInMinutes']
} as const;

export const $EndUsageSessionDto = {
    type: 'object',
    properties: {
        notes: {
            type: 'string',
            description: 'Additional notes about the completed session',
            example: 'Print completed successfully'
        },
        endTime: {
            format: 'date-time',
            type: 'string',
            description: 'The end time of the session. If not provided, current time will be used.'
        }
    }
} as const;

export const $GetResourceHistoryResponseDto = {
    type: 'object',
    properties: {
        total: {
            type: 'number'
        },
        page: {
            type: 'number'
        },
        limit: {
            type: 'number'
        },
        nextPage: {
            type: 'number',
            description: 'Next page number if there are more pages, null if this is the last page',
            example: 2,
            nullable: true
        },
        totalPages: {
            type: 'number',
            description: 'Total number of pages',
            example: 5
        },
        data: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/ResourceUsage'
            }
        }
    },
    required: ['total', 'page', 'limit', 'nextPage', 'totalPages', 'data']
} as const;

export const $GetActiveUsageSessionDto = {
    type: 'object',
    properties: {
        usage: {
            description: 'The active usage session or null if none exists',
            nullable: true,
            allOf: [
                {
                    '$ref': '#/components/schemas/ResourceUsage'
                }
            ]
        }
    },
    required: ['usage']
} as const;

export const $CanControlResponseDto = {
    type: 'object',
    properties: {
        canControl: {
            type: 'boolean',
            description: 'Whether the user can control the resource'
        }
    },
    required: ['canControl']
} as const;

export const $IsResourceIntroducerResponseDto = {
    type: 'object',
    properties: {
        isIntroducer: {
            type: 'boolean',
            description: 'Whether the user is an introducer for the resource'
        }
    },
    required: ['isIntroducer']
} as const;

export const $UpdateResourceIntroductionDto = {
    type: 'object',
    properties: {
        comment: {
            type: 'string',
            description: 'The comment for the action',
            example: 'This is a comment'
        }
    }
} as const;

export const $PluginMainFrontend = {
    type: 'object',
    properties: {
        directory: {
            type: 'string',
            description: 'The directory of the plugins frontend files',
            example: 'frontend'
        },
        entryPoint: {
            type: 'string',
            description: 'The entry point of the plugin, relative to the frontend directory',
            example: 'index.mjs'
        }
    },
    required: ['directory', 'entryPoint']
} as const;

export const $PluginMainBackend = {
    type: 'object',
    properties: {
        directory: {
            type: 'string',
            description: 'The directory of the plugins backend files',
            example: 'backend'
        },
        entryPoint: {
            type: 'string',
            description: 'The entry point of the plugin, relative to the backend directory',
            example: 'index.mjs'
        }
    },
    required: ['directory', 'entryPoint']
} as const;

export const $PluginMain = {
    type: 'object',
    properties: {
        frontend: {
            description: 'The frontend files of the plugin',
            example: {
                directory: 'frontend',
                entryPoint: 'index.mjs'
            },
            allOf: [
                {
                    '$ref': '#/components/schemas/PluginMainFrontend'
                }
            ]
        },
        backend: {
            description: 'The backend file of the plugin',
            example: {
                directory: 'backend',
                entryPoint: 'src/plugin.js'
            },
            allOf: [
                {
                    '$ref': '#/components/schemas/PluginMainBackend'
                }
            ]
        }
    },
    required: ['frontend', 'backend']
} as const;

export const $PluginFabAccessVersion = {
    type: 'object',
    properties: {
        min: {
            type: 'string',
            description: 'The minimum version of the plugin',
            example: '1.0.0'
        },
        max: {
            type: 'string',
            description: 'The maximum version of the plugin',
            example: '1.0.0'
        },
        exact: {
            type: 'string',
            description: 'The exact version of the plugin',
            example: '1.0.0'
        }
    },
    required: ['min', 'max', 'exact']
} as const;

export const $LoadedPluginManifest = {
    type: 'object',
    properties: {
        name: {
            type: 'string',
            description: 'The name of the plugin',
            example: 'plugin-name'
        },
        main: {
            '$ref': '#/components/schemas/PluginMain'
        },
        version: {
            type: 'string',
            description: 'The version of the plugin',
            example: '1.0.0'
        },
        fabaccessVersion: {
            '$ref': '#/components/schemas/PluginFabAccessVersion'
        },
        pluginDirectory: {
            type: 'string',
            description: 'The directory of the plugin',
            example: 'plugin-name'
        },
        id: {
            type: 'string',
            description: 'The id of the plugin',
            example: '123e4567-e89b-12d3-a456-426614174000'
        }
    },
    required: ['name', 'main', 'version', 'fabaccessVersion', 'pluginDirectory', 'id']
} as const;

export const $UploadPluginDto = {
    type: 'object',
    properties: {
        pluginZip: {
            type: 'string',
            description: 'Plugin zip file',
            format: 'binary'
        }
    },
    required: ['pluginZip']
} as const;

export const $EnrollNfcCardDto = {
    type: 'object',
    properties: {
        readerId: {
            type: 'number',
            description: 'The ID of the reader to enroll the NFC card on',
            example: 1
        }
    },
    required: ['readerId']
} as const;

export const $EnrollNfcCardResponseDto = {
    type: 'object',
    properties: {
        message: {
            type: 'string',
            description: 'Success message',
            example: 'Enrollment initiated, continue on Reader'
        }
    },
    required: ['message']
} as const;

export const $ResetNfcCardDto = {
    type: 'object',
    properties: {
        readerId: {
            type: 'number',
            description: 'The ID of the reader to reset the NFC card on',
            example: 1
        },
        cardId: {
            type: 'number',
            description: 'The ID of the NFC card to reset',
            example: 123
        }
    },
    required: ['readerId', 'cardId']
} as const;

export const $ResetNfcCardResponseDto = {
    type: 'object',
    properties: {
        message: {
            type: 'string',
            description: 'Success message',
            example: 'Reset initiated, continue on Reader'
        }
    },
    required: ['message']
} as const;

export const $UpdateReaderDto = {
    type: 'object',
    properties: {
        name: {
            type: 'string',
            description: 'The name of the reader',
            example: 'Main Entrance Reader'
        },
        connectedResources: {
            description: 'The IDs of the resources that the reader has access to',
            type: 'array',
            items: {
                type: 'number'
            }
        }
    },
    required: ['name', 'connectedResources']
} as const;

export const $FabReader = {
    type: 'object',
    properties: {
        id: {
            type: 'number',
            description: 'The ID of the reader'
        },
        name: {
            type: 'string',
            description: 'The name of the reader'
        },
        hasAccessToResourceIds: {
            description: 'The IDs of the resources that the reader has access to',
            type: 'array',
            items: {
                type: 'number'
            }
        },
        lastConnection: {
            format: 'date-time',
            type: 'string',
            description: 'The last time the reader connected to the server'
        },
        firstConnection: {
            format: 'date-time',
            type: 'string',
            description: 'The first time the reader connected to the server'
        },
        connected: {
            type: 'boolean',
            description: 'Whether the reader is currently connected'
        }
    },
    required: ['id', 'name', 'hasAccessToResourceIds', 'lastConnection', 'firstConnection', 'connected']
} as const;

export const $UpdateReaderResponseDto = {
    type: 'object',
    properties: {
        message: {
            type: 'string',
            description: 'Success message',
            example: 'Reader updated successfully'
        },
        reader: {
            description: 'The updated reader',
            allOf: [
                {
                    '$ref': '#/components/schemas/FabReader'
                }
            ]
        }
    },
    required: ['message', 'reader']
} as const;

export const $AppKeyRequestDto = {
    type: 'object',
    properties: {
        cardUID: {
            type: 'string',
            description: 'The UID of the card to get the app key for',
            example: '04A2B3C4D5E6'
        },
        keyNo: {
            type: 'number',
            description: 'The key number to generate',
            example: 1
        }
    },
    required: ['cardUID', 'keyNo']
} as const;

export const $AppKeyResponseDto = {
    type: 'object',
    properties: {
        key: {
            type: 'string',
            description: 'Generated key in hex format',
            example: '0A1B2C3D4E5F6789'
        }
    },
    required: ['key']
} as const;

export const $NFCCard = {
    type: 'object',
    properties: {
        id: {
            type: 'number',
            description: 'The ID of the NFC card'
        },
        uid: {
            type: 'string',
            description: 'The UID of the NFC card'
        },
        userId: {
            type: 'number',
            description: 'The ID of the user that owns the NFC card'
        },
        createdAt: {
            format: 'date-time',
            type: 'string',
            description: 'The date and time the NFC card was created'
        },
        updatedAt: {
            format: 'date-time',
            type: 'string',
            description: 'The date and time the NFC card was last updated'
        }
    },
    required: ['id', 'uid', 'userId', 'createdAt', 'updatedAt']
} as const;